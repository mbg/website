---
title: Practical 3 - Compiler Construction
---

In the third part of the practical, you will be completing the compiler\'s code generator which turns the AST of the STG language into a C program. We choose C as our target language because of how portable and widely-supported it is.

## Upgrading the Skeleton Code

This practical continues where we left off in the previous practical. To begin, [follow the instructions for upgrading your code](upgrade.html) to obtain the skeleton code for this practical.

## Task: Warmup

To get started, we will make the program in the \texttt{example1} folder compile. Open the \texttt{./src/CodeGen.hs} file, which contains the parts of the code generator you will need to modify / implement, and find the definition of the $\mathit{compExpr}$ function. Scroll down all the way to the bottom of the file to the case for primitive literals - this corresponds to $\mathit{ReturnInt}$ state of the machine:

```haskell
compExpr (LitE v _) = do
    -- pop the continuation off the pointer stack
    k <- loadLocalFromStack ValStk 0 "_k" (MonoTy $ AlgTy "_Cont")
    adjustStack ValStk (-1)

    -- set the return register value
    -- returnVal v

    -- jump to the continuation
    jump k
```

Some silly academic has commented out the line which stores the value of the literal in the \texttt{Ret} register (see Appendix \ref{app:registers}), because apparently the code generator part became irrelevant after he implemented a working type checker. Anyway, the \mathit{returnVal} function of type `PrimInt -> CodeGenFn ()` is part of a sort-of domain specific language (largely defined in \texttt{src/AbstractC.hs}) which you can use to generate C code without having to manually spell out C syntax.

Uncomment the line and compile your compiler with \texttt{cabal build}. Once you have successfully compiled the compiler, navigate to the \texttt{./tests/codegen/example1} folder and run \texttt{make}. This should produce an executable named \texttt{a} and a source file named \texttt{Prim.c} in the same folder. Run \texttt{a} to see a trace of the execution of the program, along with the final result of \texttt{42} in the \texttt{Ret} register. Open \texttt{Prim.c} to see the source code for the program:

```c
#include "rts.h"
// prototypes
StgWord main_closure[1];
StgWord main_info[1];
CodeLabel main_entry();
// static closures and info tables
StgWord main_closure[] = {main_info};
StgWord main_info[] = {main_entry};
// code
CodeLabel main_entry() {
    printf("main_entry\n");
    if (SpPtr > SpVal) { stack_overflow(); }
    StgWord _k = SpVal[1];
    SpVal += 1;
    Ret = 42;
    JUMP(_k);
}
```

For every global binding, the code generator generates a closure (`main\_closure` for the `main` function in \texttt{Prim.stg}), consisting of a pointer to the closure\'s info table and pointers to all of its free variables. `main` does not have any free variables, so `main\_closure` consists of a single pointer to the corresponding info table, `main\_info`. Don\'t worry about what info tables are just yet, since they won\'t become important until the next exercise. For now, info tables will always consist of exactly one pointer to the closure\'s standard entry code.

The standard entry code for the closure belonging to `main` is the creatively-named `main\_entry`. This is a continuation in the style presented in the theory questions above. The STG-machine\'s runtime system, defined in \texttt{rts.c} and \texttt{rts.h} will always begin evaluation with \texttt{main\_entry}. The body of the function is obtained by compiling the expression contained in the lambda-form for `main`. In the case of \texttt{Prim.stg}, the expression belonging to \texttt{main} is just a primitive integer. To illustrate how the code is generated by `compExpr`\'s case for primitive integers, you can find an annotated version of \texttt{Prim.c} below, where each line is annotated with the corresponding Haskell source code that generated it:

```c
CodeLabel main_entry() {
    printf("main_entry\n");
    if (SpPtr > SpVal) { stack_overflow(); }

    // -- pop the continuation off the pointer stack
    // k <- loadLocalFromStack ValStk 0 "_k" (MonoTy $ AlgTy "_Cont")
    StgWord _k = SpVal[1];

    // adjustStack ValStk (-1)
    SpVal += 1;

    // -- set the return register value
    // returnVal v
    Ret = 42;

    // -- jump to the continuation
    // jump k
    JUMP(_k);
}
```

As described in Appendix \ref{app:stacks}, there are two stacks: the pointer and the value stack. Continuations are stored on the value stack, referred to as $\mathit{ValStk}$ in the Haskell code. A call to `adjustStack s n` for some stack `s` and some integer `n` if `n` is positive indicates that `n`-many items were pushed onto the stack `s` or that `n`-many items were popped off the stack if `n` is negative. The `adjustStack` function will automatically work out whether this should translate into an instruction which increments or decrements the respective stack pointer. In this case, since the value stack grows from higher memory addresses to lower memory addresses, it results in the pointer being incremented as a result of an item getting popped off it. Note that none of the functions which push or pop items off/onto the two stacks, such as `loadLocalFromStack` will ever adjust the stack pointers themselves! This is so that you can try to group several pushes/pops into a single instruction which adjusts the respective stack pointer.

The `loadLocalFromStack` function also takes an index into the stack as an argument (set to 0 in the code above), which allows you to index into arbitrary positions in the stacks. A value of 0 will get translated into the position corresponding to the element at the top of the stack (1 for the value stack and -1 for the pointer stack). The final argument of the function is the type of the local. The continuation has no real type, so we just assign it an arbitrary type which cannot possibly appear in a source program (the leading underscore wouldn\'t be a valid name in the STG language).

## Task: Compiling operators

Complete the definition of `compExpr`\'s case for `OpE` (just above the one for `LitE`):

```haskell
compExpr (OpE op [x,y] _) = do
    -- pop the continuation off the pointer stack

    -- compile the operator application

    -- jump to the continuation
    undefined
```

This corresponds to Rule 15 of the operational semantics. It should do exactly the same as the case for `LitE` except, instead of storing the value of a literal in the `Ret` register, you should call the `compBuiltIn` function (defined just above `compExpr`) to compile the operator application for you. If successful, the \texttt{example2} program should compile and produce the expected result.

## Task: Compiling constructor applications

Next, we will compile constructor applications. Recall that all evaluation in the STG-machine is performed by `case`-expressions. For the primitive integers we have dealt with so far, the code generated for a corresponding `case`-expression pushes a continuation onto the value stack which is then acquired by the code for the primitive and jumped to. (The runtime system in \texttt{rts.c} pretends that `main` is wrapped into a `case`-expression on primitive integers by pushing the `finished` continuation onto the value stack before evaluating `main`.) The continuation can then decide what to do based on the value in the `Ret` register.

For constructors, things get a bit more tricky. A corresponding `case`-expression will push a pointer to a vector of continuations - one for each constructor belonging to a given type - onto the value stack. The code generated for a constructor must pop this pointer off the value stack and then choose the appropriate continuation to jump to. The relevant skeleton code is shown below:

```haskell
compExpr (CtrE c as _) = do
    -- obtain the return vector from the value stack
    undefined

    -- allocate a closure for the arguments
    unless (null as) $ do
        -- allocate enough memory for all of the constructor's arguments and
        -- a pointer to the constructor's info table
        -- NOTE: the info table bit is not implemented, since it is slightly
        --       tricky -- see the note in the definition of `compAlgDefault'
        undefined

        -- set the node register to the right location
        withVar "_c" $ \sym -> writeRegister NodeR sym

    -- look up the index of the constructor and jump to the
    -- corresponding entry in the return vector
    r <- lift $ lift $ lookupCtrIndex c

    case r of
        Nothing  -> error "Internal error: constructor not found"
        (Just i) -> jump (IndexSym (RegisterSym RetVecR) i)
```

* There are two `undefined`s here. Let\'s tackle the first one: obtain the return vector from the value stack. There is a special register for return vectors, named `RetVec` in the C code and `RetVecR` in Haskell. There is also a `loadRegisterFromStack` function of type `Register -> Stack -> Int -> CodeGenFn ()` which loads a value at some index from some stack and stores it in some register. Replace the first `undefined` with an appropriate call to `loadRegisterFromStack`. Don\'t forget to also adjust the stack afterwards.
* Consider the following, slightly silly, program in the STG language:

```haskell
case Cons {x,xs} of
    Cons {y,ys} -> y {};
    Nil {} -> ...
    default -> ...
```

This `case`-expression will push the pointer to a return vector with two entries onto the value stack. Assuming that we have defined \texttt{type List {a} = Nil | Cons a (List a)}, then the first entry in the return vector will be for the \texttt{Nil} case and the second entry for the \texttt{Cons} case. No entry in this return vector will point to the \texttt{default} case, since all cases are covered. The code generated for \texttt{Cons \{x,xs\}} will therefore pick the second entry in the return vector and jump to it, but how does that continuation find \texttt{x} and \texttt{xs}? The answer is: we must allocate some memory on the heap (see Appendix \ref{app:heap}) for a closure whose free variables point to the constructor\'s arguments. For simplicity, we won\'t set the info table pointer to anything. Replace the second `undefined` in the skeleton code to do this. There are two functions which will help you:
\begin{itemize}
\item $\mathit{allocMemory}$ generates code which will allocate some memory on the heap. The first argument is a $\mathit{String}$ which gives a name to the resulting region of memory during code generation. You should set this to \texttt{"\_c"}, because that's what the subsequent $\mathit{withVar}$ function expects. The second argument is the amount of memory to allocate in words. Remember to allocate enough space for a pointer to the info table (which we won't set to anything) and all of the constructor's arguments (in scope as $\mathit{as}$). $\mathit{allocMemory}$ is the rough equivalent of $\mathit{adjustStack}$ for the heap; the resulting code will only adjust the heap pointer, \texttt{Hp}.
\item $\mathit{storeAtomsOnHeap}$ generates code which stores a list of atoms on the heap. The first argument, $n$, indicates the negative offset, relative to the heap pointer, at which the function should start storing arguments. Since the heap grows from lower to higher memory addresses and $\mathit{allocMemory}$ increments the heap pointer by the amount of memory requested, subsequent instructions which store things on the heap must subtract from the heap pointer. For example
\begin{verbatim}
allocMemory "_foo" 2
storeAtomsOnHeap 2 [LitAtom (MkPrimInt 23),LitAtom (MkPrimInt 42)]
\end{verbatim}
will generate code which first increments \texttt{Hp} by two and refers to the previous location pointed to by \texttt{Hp} as \texttt{\_foo}
\begin{center}
\begin{drawstack}
  \cell{} \cellptr{\texttt{\_foo}}
  \cell{}
  \cell{} \cellptr{\texttt{Hp}}
\end{drawstack}
\end{center}
and then stores the two literal atoms on the heap as follows:
\begin{center}
\begin{drawstack}
  \cell{23} \cellptr{\texttt{\_foo}}
  \cell{42}
  \cell{} \cellptr{\texttt{Hp}}
\end{drawstack}
\end{center}
\end{itemize}

## Task: Compiling function application

Function application is compiled by pushing all arguments onto the respective stacks and then entering the closure represented by the function:

```haskell
compExpr (AppE f as _) = do
    -- push arguments onto the appropriate stacks and adjust the stack
    -- pointers accordingly
    undefined

    -- enter the closure pointed to by f
    withVar (varName f) $ \sym -> compEnter sym
```

Replace the `undefined` in the case for `AppE` with statements which generate C code to push the function\'s arguments onto the respective stacks. The `pushArgs` function (defined in \texttt{CodeGen.hs}) can do most of the work for you. It takes two arguments: a pair of offsets into the value and pointer stacks, and a list of atoms to push onto the stacks. The function will work out which stack each atom needs to be pushed onto and it will return the final offsets as a pair. So, if you start at the top of each stack (offsets (0,0)), then you would get back a pair telling you how many items were pushed onto each stack. The first section of the pair corresponds to the value stack and the second to the pointer stack.

## Task: Popping arguments off the stacks

The opposite code, which pops the arguments off the stacks, needs to go into the definition of $\mathit{standardEntry}$ (in \texttt{CodeGen.hs}, shortened):

```haskell
-- | `standardEntry lf' generates the standard entry code for `lf'
standardEntry :: ALambdaForm PolyType -> CodeGenFn ()
standardEntry (MkLambdaForm fvs uf vs e) = do
    -- some other code you don't need to worry about

    -- for simplicity, we pop all arguments off the stack here
    -- a more efficient implementation might leave them on the stack
    -- if possible
    -- YOUR CODE HERE

    -- compile the expression
    compExpr e
```

There is a function called $\mathit{loadArgs}$ which does the opposite of $\mathit{pushArgs}$. It generates code to pop items off the two stacks, starting from the tops of the stacks if the initial offsets are (0,0), until it has done so for every variable in the list that it is given. \emph{Hint}: since it starts the top of the stacks, the arguments will be popped in reverse order compared to the order in which they were pushed onto the stacks. You will need to account for that either here or in your code for $\mathit{AppE}$. Once done, \texttt{example3} should produce the right result.

## Task:

Similarly, the `compAlgAltCont` function generates the entry code for an algebraic case alternative - *i.e.* a continuation in a return vector. Remember how you stored a constructor\'s arguments on the heap? You need to load them from the heap here:

```haskell
-- | `compAlgAltCont alt' generates code for an algebraic alternative.
compAlgAltCont :: LocalEnv -> AAlgAlt PolyType -> CodeGenFn ()
compAlgAltCont env (AAlt c vs e t) = do
    restoreEnvironment env

    -- pattern variables will be on the heap
    -- YOUR CODE HERE

    -- generate the code for the expression
    compExpr e
```

There are two functions which will be helpful here: `deallocateMemory` and `loadHeapArgs`. Since we know that the constructor\'s code will have been the last thing that got executed before jumping to the continuation we are generating code for here, we can safely deallocate the memory used by the arguments. `deallocateMemory n` deallocates `n` words on the heap. `loadHeapArgs i vs` loads values from the heap and dumps them into local variables, starting at `Hp + i`, for all variables in `vs`. So, if you call `deallocateMemory` first with the size of the closure, `Hp` will point at the non-existant info pointer and the first argument will be at offset 1. Once implemented, \texttt{example4} should compile.

## Task: Allocating Closures

Finally, in order to get \texttt{example5} to work, you must finish the definition of $\mathit{allocClosures}$ which generates the code for local bindings. Specifically, you need to fill in the code which allocates heap memory for a closure and stores the info pointer as well as the free variables on the heap:

```c
-- | `allocClosures bs' allocates dynamic closures on the STG heap for all
--   bindings in `bs'
allocClosures :: [ABind PolyType] -> CodeGenFn ()
allocClosures [] = return ()
allocClosures (MkBind (Var n _) lf t : bs) = do
    -- generate the standard entry code for the closure
    entry <- lift $ lift $
        withNewFunction (n ++ "_entry_") (standardEntry lf)

    -- generate an info table on the C heap
    tbl <- lift $ lift $ infoTbl n entry

    -- calculate the size of the closure for this binding and allocate memory
    -- on the STG heap and refer to it as `n'
    let
        s = closureSize lf

    -- YOUR CODE HERE

    -- continue with the other bindings
    allocClosures bs
```

In addition to function(s) which you may have encountered for previous questions, you will also need:

* `writeHeap` generates code to write something of type `Symbol a` to a location on the heap (such as the info table, `tbl`).
* `storeVarsOnHeap` generates code to store variables on the heap, similarly to `storeAtomsOnHeap`.

## Task: Testing

The test cases in the \texttt{/tests/codegen/} folder are likely not exhaustive. Try to come up with your own test cases which increase the test coverage \textbf{and} submit them as pull requests to the \url{https://github.com/mbg/compconstr-code} repository. You should keep an eye out for any new test cases that appear there, as well. Does your code generator pass them? Bonus points if you find a test case which breaks my model implementation. Note that there are some things which have been omitted from the code generator to keep things relatively simple:


* Updatable closures are treated as not-updatable. No code related to updates is generated.
* Default case alternatives for algebraic types, which bind a variable, are not implemented to keep you sane.
* Some stack / heap checks are not implemented (this will likely be addressed in the upcoming supervision work).



The skeleton code comes with a basic test suite for the compiler. You can run the test suite using Stack:

```sh
$ stack test
```

This will run all regression tests in the test suite and report on the outcome. If you run the test suite without completing the exercises, you will get a result similar to the following which indicates that one test was performed and failed, preceded by more details about the failure which have been omitted here:

```sh
Finished in 0.0110 seconds
1 example, 1 failure

Completed 2 action(s).
Test suite failure for package stg-0.1.0.0
   spec:  exited with: ExitFailure 1
Logs printed to console
```

The regression tests are contained in the [tests](https://github.com/mbg/compconstr-code/tree/supervision2/tests) folder. Each test consists of a `.stg` file and a `.stdout` file which otherwise share the same filename. The `.stg` file contains the STG program that should be parsed and the `.stdout` file contains the expected compiler output. If the output generated by the compiler as a result of parsing the `.stg` file matches that specified in the `.stdout` file, the test is successful. Otherwise, the test fails. Currently, there is only one regression test. To add additional regression tests to the test suite, place additional `.stg` and `.stdout` files in the [tests](https://github.com/mbg/compconstr-code/tree/master/tests) folder. You will also need to add the name of the `.stg` file to the `files` list in the [test/ParserSpec.hs](https://github.com/mbg/compconstr-code/blob/supervision2/test/ParserSpec.hs#L27) file.

Thoroughly test your code generator to ensure that all rules in the operational semantics are compiled correctly, according to [the specification](compiler-spec.pdf). Explain how you have tested your code generator and why you are convinced that it is correct.
